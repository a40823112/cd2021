<h1>Introduction</h1>
<p>Github : <a href="https://github.com/a40823112">40823112</a></p>
<p>Repository : <a href="https://github.com/a40823112/cd2021">cd2021 </a></p>
<p>Website : <a href="https://a40823112.github.io/cd2021/content/index.html">cd2021 website</a></p>
<p>Group r<span>epository : <a href="https://github.com/a40823112/stage1-ag10">stage1-ag10</a> , <a href="https://github.com/a40823112/stage2-ag1">stage2-ag1</a></span></p>
<p><span>Group website : </span><a href="https://a40823112.github.io/stage1-ag10/content/index.html">stage1-ag10</a> , <a href="https://a40823112.github.io/stage2-ag1/content/index.html">stage2-ag1</a></p>
<p>Stage1-Job description: coppeliasim模擬、reveal.js與PDF報告製作、倉儲網頁編輯</p>
<p><span>Stage2-Job description: coppeliasim模擬、reveal.js製作、倉儲網頁編輯</span></p>
<h1>Collaboration</h1>
<p><span>何謂協同??</span></p>
<p><span>協同設計與版次管理能夠有效提升團隊工作效率，降低內容互相覆蓋，最終造成無法辨識是誰更改內容的情況。</span></p>
<p><span>每一個協同者製作與更改的項目都會顯示在上面，不怕後者更新會覆蓋前者所製作的，還能輕易地找出之前所做的每一項目。</span></p>
<p><a href="https://a40823112.github.io/cd2021/content/%E5%8D%94%E5%90%8C%E5%80%89%E5%84%B2.html">與組長協同倉儲教學</a></p>
<p><span><img alt="" height="619" src="/images/Synergy-1.jpg" width="850"/></span></p>
<p><span></span>(此圖為40823145在 stage2 ag1 所製作)</p>
<p></p>
<h1>Stage 1</h1><h2>W1</h2>
<h3>利用SSH維護倉儲</h3>
<p><strong><span color="blue" size="3" style="color: blue; font-size: large;">新增鑰匙:</span></strong></p>
<p><strong>Step1: </strong>使用編輯器進入shell命令環境</p>
<p><img alt="" height="316" src="/images/ssh 1.jpg" width="600"/></p>
<p><strong>Step2:</strong>輸入指令，在<em><strong>y/tmp/key/id_rsa</strong></em>目錄下新增id_rsa與id_rsa等<strong>private key</strong>與<strong>public key</strong></p>
<pre class="brush:html;auto-links:false;toolbar:false" contenteditable="false">ssh-keygen -t rsa -b 4096 -C "學號"
</pre>
<p><img alt="" height="316" src="/images/ssh 2.jpg" width="600"/></p>
<p><strong>Step3:</strong>開啟Y/Putty目錄下的<strong>puttygen.exe</strong>將id_rsa轉為Putty可解讀的.ppk格式</p>
<p><img alt="" height="588" src="/images/ssh3.jpg" width="600"/></p>
<p><strong>Step4:</strong>將<strong>public key</strong>利用scite開啟，在工具列中<strong>Options-Wrap</strong>就可見完整的檔案內容</p>
<p><strong>Step5:</strong>將內容複製後，開啟<strong>github settings</strong>中的<strong>SSH and GPD keys</strong></p>
<p><strong><img alt="" height="502" src="/images/ssh4.jpg" width="301"/></strong></p>
<p>選擇<strong> New SSH keys</strong></p>
<p><strong><img alt="" height="146" src="/images/ssh5.jpg" width="654"/></strong></p>
<p>將複製內容放入KEY的空格</p>
<p><img alt="" height="341" src="/images/ssh6.jpg" width="600"/></p>
<p><strong><span color="blue" size="3" style="color: blue; font-size: large;">設定Putty:</span></strong></p>
<p><strong>Step1:</strong>修改<strong>start.bat</strong>設定，新增</p>
<pre class="brush:html;auto-links:false;toolbar:false" contenteditable="false">set GIT_HOME=%Disk%:\portablegit\bin\
set GIT_SSH=%Disk%:\putty\plink.exe</pre>
<p><strong>Step2:</strong>設定<strong>y/home/.shh</strong>中的<strong>config</strong></p>
<p><strong><img alt="" height="671" src="/images/ssh config.jpg" width="600"/></strong></p>
<p><strong>Step3:</strong>將倉儲中.git目錄下的config連線設定，由https更改為ssh連線</p>
<p><img alt="" height="672" src="/images/ssh url.jpg" width="600"/></p>
<p><strong>Step4:</strong>開啟 <strong>Putty.exe</strong></p>
<p><strong><img alt="" height="467" src="/images/putty exe.jpg" width="600"/></strong></p>
<p><strong>Step5:Load github.com</strong></p>
<p><strong><img alt="" height="588" src="/images/putty exe1.jpg" width="600"/></strong></p>
<p><strong>Step6:</strong>進入<strong>Connection/SSH/Auth</strong>選擇之前創的Key</p>
<p><img alt="" height="583" src="/images/putty exe2.jpg" width="600"/></p>
<p><strong>Step7:</strong>回到<strong>Session按save</strong></p>
<p><strong><img alt="" height="584" src="/images/putty exe3.jpg" width="600"/></strong></p>
<p><strong>Step8:</strong>按下<strong>open</strong>後就可進行push</p>
<p></p>
<h3>建立倉儲</h3>
<p><strong>Step1:</strong>在mdecourse的cmstemplate倉儲下按<em><strong>Use this template</strong></em></p>
<p><em><strong><img alt="" height="444" src="/images/step1.jpg" width="600"/></strong></em></p>
<p><strong>Step2:</strong>在<em><strong>Repository name</strong></em>中輸入cd2021</p>
<p><img alt="" height="434" src="/images/step2.jpg" width="600"/></p>
<p><strong>Step3:</strong>在Y槽的tmp目錄下clone倉儲，在編輯器中輸入</p>
<pre class="brush:html;auto-links:false;toolbar:false" contenteditable="false">git clone --recurse-submodules https://github.com/學號/cd2021.git</pre>
<p><strong>Step4:</strong>利用編輯器在cd2021目錄下輸入</p>
<pre class="brush:html;auto-links:false;toolbar:false" contenteditable="false">python wsgi.py</pre>
<p><img alt="" height="549" src="/images/step4.jpg" width="600"/></p>
<p>倉儲建立完成</p>
<h3>建立Leo編輯Palican</h3>
<p><strong>Step1:</strong>在tmp的目錄下輸入</p>
<pre class="brush:html;auto-links:false;toolbar:false" contenteditable="false">leo</pre>
<p><strong><img alt="" height="312" src="/images/leo step1.jpg" width="600"/></strong></p>
<p><strong>Step2:</strong>若開啟leo時出現此畫面，則需到<em><strong>Y/home/.leo</strong></em>中新增<strong>.leoID的txt文字檔，</strong>內容隨意</p>
<p><img alt="" height="190" src="/images/leo step2.jpg" width="252"/></p>
<p><img alt="" height="456" src="/images/leo step2_1.jpg" width="348"/></p>
<p><strong>Step3:</strong>重新啟動編輯器後就可開啟</p>
<p><img alt="" height="472" src="/images/leo step3.jpg" width="600"/></p>
<p><strong>Step4:</strong>按<em><strong>File</strong></em>中的<em><strong>Open-Outline</strong></em>，選取<em><strong>Y/tmp/cd2021/config/pelican.leo</strong></em></p>
<p><em><strong><img alt="" height="473" src="/images/leo step4.jpg" width="600"/></strong></em></p>
<p><em><strong><img alt="" height="467" src="/images/leo step4_2.jpg" width="600"/></strong></em></p>
<p><strong>Step5:</strong>在<strong>Pelican設定</strong>下的<strong>@edit pelicanconf.py</strong>更改<em><strong>AUTHOR、SITENAME</strong></em></p>
<p><em><strong><img alt="" height="473" src="/images/leo step5.jpg" width="600"/></strong></em></p>
<p><strong>Step6:</strong>更改<strong>@edit publishconf.py</strong>中的<strong>SITEURL</strong></p>
<p><strong><img alt="" height="469" src="/images/leo step6.jpg" width="600"/></strong></p>
<p><strong>Step7:</strong>在<strong>markdown</strong>下更改Blog內容</p>
<p><img alt="" height="476" src="/images/leo step7.jpg" width="600"/></p>
<p><strong>Step8:</strong>更改完後，在編輯器上輸入就可push</p>
<pre class="brush:html;auto-links:false;toolbar:false" contenteditable="false">pelican markdown -o blog -s local_publishconf.py
pelican markdown -o blog -s publishconf.py</pre>
<h3>協同倉儲</h3>
<p><strong>Step 1 :</strong>進入倉儲的setting，並選擇<span>Manage access</span></p>
<p><span><img alt="" height="393" src="/images/Manage access.jpg" width="850"/></span></p>
<p><span><strong>Step 2 :</strong>點選<strong> Invite a collaboratot</strong></span></p>
<p><span><span><img alt="" height="393" src="/images/Invite a collaboratot.jpg" width="850"/></span></span></p>
<p><span><span><strong>Step 3 : 組長與組員互相邀請</strong></span></span></p>
<p><span><span><strong>1.組長 </strong>需輸入組員github名稱</span></span></p>
<p><span><span><strong>2.組員 </strong><span>需輸入組員github名稱</span></span></span></p>
<p><span><span><img alt="" height="319" src="/images/Invite a collaboratot name.jpg" width="532"/></span></span></p>
<p><span><span><strong>Step 4 : </strong>組員clone組長倉儲並在倉儲下輸入 </span></span></p>
<pre class="brush:py;auto-links:false;toolbar:false" contenteditable="false">git clone --recurse-submodules https://github.com/組長/stage2-ag1.git stage2-ag1      clone組長倉儲
cd stage2-ag1
git remote add 組員 https://github.com/40823145/stage2-ag1.git     git add自己倉儲</pre>
<p></p>
<p>⭐⭐組員在push時，若需要上傳至小組倉儲則輸入<strong>git push ，</strong>而要上傳至自己倉儲時則輸入<strong>git push 組員</strong></p>
<h2>W2</h2>
<h3>Project production</h3>
<p>與隊友討論後決定製作 <em><strong>Da Vinci's Paddle Boat </strong></em></p>
<p><em><strong><span>進度規劃:</span></strong></em></p>
<p><strong><span>W2:</span></strong>討論與繪製零件圖</p>
<p><strong>W3:</strong>進行coppeliasim模擬、網頁與報告製作</p>
<p><strong>W4:</strong>網頁報告與製作</p>
<p><em><strong><img alt="" height="301" src="/images/介紹圖.jpg" width="545"/></strong></em></p>
<h3>手繪草稿</h3>
<p>1.與組員討論的初期手稿:</p>
<p><img alt="" height="800" src="/images/手稿1.jpg" width="600"/></p>
<p>2.發現左右兩齒輪旋轉方向不同而更改草圖</p>
<p><img alt="" height="450" src="/images/手稿2.jpg" width="600"/></p>
<p>3.模擬後發現惰輪會使左右齒輪轉速不同而修改</p>
<p><img alt="" height="1051" src="/images/討論手稿.jpg" width="600"/></p>
<h3>初步設計與討論</h3>
<p>討論船的傳動方式，如何使左右船槳能同方向旋轉。</p>
<p><em><strong><mark>討論結果:</mark></strong></em></p>
<p>在一邊的齒輪上多加一個惰輪更改方向。</p>
<p><img alt="" height="361" src="/images/transmission.jpg" width="600"/></p>
<p><em><strong><mark>初步設計成品:</mark></strong></em></p>
<p>將初步繪出的立體圖放入Coppeliasim進行模擬，找出需要更改設計的地方。</p>
<p><img alt="" height="379" src="/images/Preliminary product.jpg" width="600"/></p>
<h2>W3</h2>
<h3>錯誤排解 齒輪方向與速度</h3>
<p><em><strong><mark>齒輪大小與傳動方式更改</mark></strong></em></p>
<p>模擬後發現因為惰輪大小不同導致做又大齒輪轉速不同，經討論後齒輪改動如下:</p>
<p><strong>手繪草稿:(討論如何使左右齒輪速度、方向相同)</strong></p>
<p><img alt="" height="526" src="/images/討論手稿.jpg" width="300"/></p>
<p><strong>(零件更改後)</strong><img alt="" height="509" src="/images/gear problem.jpg" width="600"/></p>
<h3>錯誤排解 傳動改正</h3>
<p><em><strong><mark>傳動改良</mark></strong></em></p>
<p>齒輪傳動後發現會產生<span>簡諧</span>運動，所以更改齒數及形狀</p>
<p><span> (🔽更改前)</span></p>
<p><span><img alt="" height="302" src="/images/gear before.gif" width="600"/></span></p>
<p><span></span></p>
<p><span>(🔽更改後)</span></p>
<p><span><img alt="" height="384" src="/images/gear after.jpg" width="600"/></span></p>
<p><span>使大齒輪能穩定帶動船槳，而提高位置</span></p>
<p><span><img alt="" height="407" src="/images/葉槳高度.jpg" width="600"/></span></p>
<h3>產品簡化</h3>
<p><em><strong><mark>零件簡化</mark></strong></em></p>
<p>追求最佳化設計，而將沒必要的物件刪除</p>
<p><img alt="" height="407" src="/images/葉槳高度.jpg" width="600"/></p>
<p><img alt="" height="369" src="/images/簡化零件.jpg" width="600"/></p>
<h3>完成品</h3>
<p><img alt="" height="368" src="/images/final.jpg" width="600"/></p>
<h2>W4</h2>
<h3>2D工程圖</h3>
<p><img alt="" height="424" src="/images/0001.jpg" width="600"/></p>
<p><img alt="" height="424" src="/images/0002.jpg" width="600"/></p>
<p><img alt="" height="423" src="/images/工作圖 3_pages-to-jpg-0001.jpg" width="600"/></p>
<h3>3D爆炸圖</h3>
<p><img alt="" height="425" src="/images/1615607118608.jpg" width="600"/></p>
<h3>產品設計報告與影片</h3>
<p><iframe allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen="allowfullscreen" frameborder="0" height="280" src="https://www.youtube.com/embed/JddkguAVczg" width="560"></iframe></p>
<p><iframe height="550" src="https://drive.google.com/file/d/1F2QnKiK1PEwBbCzvEWrdgl_EwHinTfI3/preview" width="1000"></iframe></p>
<h1>Stage 2</h1><h2>W5</h2>
<h3>Stage2 Grouping</h3>
<p>進行分組與討論Stage2的產品設計。</p>
<p><strong>組員:</strong></p>
<p>40823108 <span>Repository: </span><a href="https://github.com/40823108/cd2021">40823108</a> W<span>ebsite</span><span>: </span><a href="https://40823108.github.io/cd2021">40823108</a></p>
<p>40823109<span> </span><span>Repository: </span><a href="https://github.com/40823109/cd2021">40823109</a> <span>W</span><span>ebsite</span><span>: </span><a href="https://40823109.github.io/cd2021">40823109</a></p>
<p>40823112<span> </span><span>Repository: </span><a href="https://github.com/a40823112/cd2021">40823112</a> <span>W</span><span>ebsite</span><span>: </span><a href="https://a40823112.github.io/cd2021">40823112</a></p>
<p>40823145<span> </span><span>Repository: </span><a href="https://github.com/40823145/cd2021">40823145</a> <span>W</span><span>ebsite</span><span>: </span><a href="https://40823145.github.io/cd2021">40823145</a></p>
<h3>進度規劃</h3>
<p><strong>W6: </strong>小組主題討論、<span>C</span><span>oppeliasim方向鍵操控模擬</span></p>
<p><strong>W7:</strong> C<span>oppeliasim方向鍵操控與傳感器模擬</span></p>
<p><strong>W8: </strong>Coppeliasim傳<span>感器</span>模擬、<span>網頁報告與製作</span></p>
<p><strong>W9: </strong>網頁報告與製作</p>
<h2>W6</h2>
<h3>討論</h3>
<p>分組討論完，決定Stage2的<span>產品設計內容，為Stage1-ag1的產品進行改良，並新增其它功能:</span></p>
<p><em><strong>1.利用鍵盤方向鍵操控</strong></em></p>
<p><em><strong>2.增加接近傳感器使產品自動行走時，不會撞到障礙物</strong></em></p>
<p></p>
<p><em><img alt="" height="471" src="https://a40823112.github.io/stage2-ag1/images/EV3-6.jpg" width="837"/></em></p>
<h2>W7</h2>
<h3>Coppeliasim方向鍵操控模擬</h3>
<p><span><img alt="" height="402" src="/images/方向鍵模擬.gif" width="800"/></span></p>
<p><span>(</span><span>🔽程式碼</span><span>)</span></p>
<pre class="brush:html;auto-links:false;toolbar:false" contenteditable="false">function sysCall_init() 
    left_handle= sim.getObjectHandle('left_m')
    right_handle= sim.getObjectHandle('right_m')
    MaxVel=2
    leftvelocity=0
    rightvelocity=0
    dVel=0.5;
    sim.setJointTargetVelocity(left_handle,leftvelocity)
    sim.setJointTargetVelocity(right_handle,rightvelocity)
end
 
function sysCall_actuation() 
    message,auxiliaryData=sim.getSimulatorMessage()
    while message~=-1 do
        if (message==sim.message_keypress) then
            if (auxiliaryData[1]==32) then
                -- right key
                leftvelocity=0
                rightvelocity=0
                sim.setJointForce(left_front_handle, 0)
                sim.setJointForce(right_front_handle, 0)
                break
            else
                sim.setJointForce(left_handle, 10000)
                sim.setJointForce(right_handle, 10000)
            end
            if (auxiliaryData[1]==2007) then
                -- up key
                leftvelocity=(leftvelocity+rightvelocity)/2
                rightvelocity=leftvelocity
                leftvelocity=leftvelocity+dVel
                rightvelocity=rightvelocity+dVel
            end
            if (auxiliaryData[1]==2008) then
                -- down key
                leftvelocity=(leftvelocity+rightvelocity)/2
                rightvelocity=leftvelocity
                leftvelocity=leftvelocity-dVel
                rightvelocity=rightvelocity-dVel
            end
            if (auxiliaryData[1]==2009) then
                -- left key
                leftvelocity=leftvelocity-dVel
                rightvelocity=rightvelocity+dVel
            end
            if (auxiliaryData[1]==2010) then
                -- right key
                leftvelocity=leftvelocity+dVel
                rightvelocity=rightvelocity-dVel
            end
        end
        message,auxiliaryData=sim.getSimulatorMessage()
    end
     
    if leftvelocity&gt;MaxVel then
        leftvelocity=MaxVel
    end
    if leftvelocity&lt;-MaxVel then
        leftvelocity=-MaxVel
    end
     
    if rightvelocity&gt;MaxVel then
                rightvelocity=MaxVel
    end
    if rightvelocity&lt;-MaxVel then
                rightvelocity=-MaxVel
    end
     
    sim.setJointTargetVelocity(left_handle,leftvelocity)
    sim.setJointTargetVelocity(right_handle,rightvelocity)
     
end</pre>
<h3>模擬問題與排解</h3>
<p><strong>問題:</strong><span> </span>當本體開啟運動模擬時會產生錯誤，導致產品解體</p>
<p><strong><img alt="" height="433" src="/images/HnHbWHruYE.gif" width="800"/></strong></p>
<p><strong>問題原因:</strong><span> </span>討論後發現，產品的模擬干涉太多使其無法正常運作，原因是產品的輪子跟球體上並不是完整的圓，而是由許多正方形的小格子所構成，所以在模擬時產生過多的干涉影響電腦正常模擬，因而模擬錯誤。</p>
<p><img alt="" height="697" src="/images/輪子改善.jpg" width="800"/></p>
<p><strong>問題排解:</strong><span><span> 在coppeliasim內 add-&gt;primitive shape-&gt;Cylinder 增添簡化圖形來代替原本的車輪，而原本的輪子就做為Disc的造型。</span></span></p>
<p><span><span><img alt="" height="392" src="https://a40823112.github.io/stage2-ag1/images/w7%E6%94%B9%E5%96%84.jpg" width="400"/></span></span></p>
<p><span><span><img alt="" height="125" src="https://a40823112.github.io/stage2-ag1/images/w7%E6%94%B9%E5%96%84%E6%8E%92%E5%88%97.jpg" width="200"/></span></span></p>
<p><span><span><img alt="" height="701" src="https://a40823112.github.io/stage2-ag1/images/w7%E6%94%B9%E5%96%84skin.jpg" width="600"/></span></span></p>
<p></p>
<h2>W8</h2>
<h3>Coppeliasim避障自走車</h3>
<p><strong>模擬影片</strong></p>
<p><img alt="" height="327" src="/images/障礙物模擬.gif" width="650"/></p>
<p><span>(</span><span>🔽程式碼</span><span>)</span></p>
<pre class="brush:py;auto-links:false;toolbar:false" contenteditable="false">function sysCall_init()
     
     
end
 
function sysCall_actuation()
     
end
 
function sysCall_sensing()
     
end
 
function sysCall_cleanup()
     
end
 
 
 
function sysCall_afterDelete(inData)
    for key,value in pairs(inData.objectHandles) do
        print("Object with handle "..key.." was deleted")
    end
     
end
 
function sysCall_afterCreate(inData)
    for key,value in pairs(inData.objectHandles) do
        print("Object with handle "..value.." was created")
    end
end
--]]
function speedChange_callback(ui,id,newVal)
    speed=minMaxSpeed[1]+(minMaxSpeed[2]-minMaxSpeed[1])*newVal/100
end
 
function sysCall_init()
     
    bubbleRobBase=sim.getObjectAssociatedWithScript(sim.handle_self) 
    leftMotor=sim.getObjectHandle("bubbleRob_leftMotor") 
    rightMotor=sim.getObjectHandle("bubbleRob_rightMotor") 
    noseSensor=sim.getObjectHandle("bubbleRob_sensingNose") 
    minMaxSpeed={120*math.pi/180,300*math.pi/180} 
    backUntilTime=-1 
    
        xml = '&lt;ui activate="false" closeable="false" resizeable="false" title="'..sim.getObjectName(bubbleRobBase)..' speed"&gt;'..[[
        &lt;hslider id="1" maximum="100" minimum="0" onchange="speedChange_callback"&gt;&lt;/hslider&gt;
        &lt;label style="* {margin-left: 300px;" text=""&gt;&lt;/label&gt;
        &lt;/ui&gt;
        ]]
    ui=simUI.create(xml)
    speed=(minMaxSpeed[1]+minMaxSpeed[2])*1
    simUI.setSliderValue(ui,1,100*(speed-minMaxSpeed[1])/(minMaxSpeed[2]-minMaxSpeed[1]))
end
 
function sysCall_actuation()
    result=sim.readProximitySensor(noseSensor) 
     
    if (result&gt;0) then backUntilTime=sim.getSimulationTime()+4 end 
 
    if (backUntilTime&lt;sim.getSimulationTime()) then
         
        sim.setJointTargetVelocity(leftMotor,speed)
        sim.setJointTargetVelocity(rightMotor,speed)
    else
         
        sim.setJointTargetVelocity(leftMotor,-speed/5)
        sim.setJointTargetVelocity(rightMotor,-speed/200)
    end
end
 
function sysCall_cleanup()
    simUI.destroy(ui)
end</pre>
<p><br/><br/></p>
<h3>模擬問題和排解</h3>
<p><img alt="" height="327" src="/images/感測無法做動.gif" width="650"/></p>
<p><strong>問題原因:</strong>與組員討論後發現，<span>感測器都沒有發生問題，不會做動的原因是程式打錯才無法驅動馬達。</span></p>
<p></p>
<p><strong>問題排解:</strong>更改產品物件的程式碼即可。</p>
<h2>W9</h2>
<h3>產品報告與模擬影片</h3>
<p><strong>方向鍵控制模擬</strong></p>
<p><iframe allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen="allowfullscreen" data-mce-fragment="1" frameborder="0" height="315" src="https://www.youtube.com/embed/7jbkQGgWKrI" title="YouTube video player" width="560"></iframe></p>
<p><strong>感測器模擬</strong></p>
<p><iframe allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen="allowfullscreen" data-mce-fragment="1" frameborder="0" height="315" src="https://www.youtube.com/embed/7FvVDsfVPIU" title="YouTube video player" width="560"></iframe></p>
<p><strong>PDF報告</strong></p>
<p><iframe data-mce-fragment="1" height="550" src="https://drive.google.com/file/d/1wedmypm9So7cyReRNaWF2WhBN8PPUgsP/preview" width="1000"></iframe></p><h1>Stage 3</h1><h2>W10</h2>
<h3>Task 1</h3>
<p><span>讀取 <a href="http://mde.tw/cd2021/downloads/stage3/stage3_2a.txt">stage3_2a.txt</a> , 建立 Stage3 的分組倉儲, 分組網頁, 以及各組員倉儲及網頁連結。</span></p>
<p><span>(此程式由Stage3-ag1組長 40823131 所製作)</span></p>
<pre class="brush:py;auto-links:false;toolbar:false" contenteditable="false"># open file, default is read mode, since txt content no chinese char4
# no encoding = "UTF-08" is needed
with open("123.txt") as fh:
    #匯入txt內容
    data = fh.readlines()
    data = [a.replace('4823122','40823122') for a in data]
    #由於22號座號打錯少打0，給後傳回data
    data = [b.replace('\t\t\t\t','') for b in data]
    #第三組的組員只有6人，多讀取了四個空格，因此多了四個\t，將其刪除後匯入data
    print(data)
for i in range(len(data)):
    #(len(data))=6，共有六組
    group = data[i].rstrip("\n").split("\t")
    #刪除data中的\n，並將\t作為分隔的依據
    print('&lt;p&gt;'+group[0]+'|&lt;a href="https://'+group[1]+'.github.io/stage3-ag'+group[0][9]+'"&gt;網站&lt;/a&gt;|&lt;a href="https://github.com/'+group[2]+'/stage3-ag'+group[0][9]+'"&gt;倉儲&lt;/a&gt;&lt;/p&gt;')
#用for迴圈增添每個小組的超連結網址
#print : 將字串顯示在螢幕上
#group[0] :文字檔中每一條第一個值、[1]:文字檔中每一條第二個值
#group[0][9]:文字檔中每一條第一個值的第九位
 
    for z in range(2,18,2):
    #range(2,18,2):選取文字檔中的第2格到第18格，每跳兩格選一次
        try:
            print('&lt;p&gt;'+group[z]+'|Website:'+'&lt;a href="https://'+group[z]+'.github.io/cd2021'+'"&gt;'+group[z]+'&lt;/a&gt;'+'|Repository:'+'&lt;a href="https://github.com/'+group[z]+'/cd2021'+'"&gt;'+group[z]+'&lt;/a&gt;&lt;/p&gt;')
            #用for迴圈增添每個組員的超連結網址
            #group[z] : 選取z跳的值
        except:
            continue
            #由於有一組是6人，在執行程式時會超出範圍影響輸出，所以需用try execot解決</pre>
<p></p>
<h2>W11</h2>
<h3>task 2-1</h3>
<p><strong>Stage-ag10 Remote API 操控</strong></p>
<p>由於我們設計的產品只有一個轉軸，所以只須設定一個變數。</p>
<p><iframe allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen="allowfullscreen" frameborder="0" height="315" src="https://www.youtube.com/embed/8XAT6MWlmIQ" title="YouTube video player" width="560"></iframe></p>
<p></p>
<p><strong>CoppeliaSim child script :</strong></p>
<p><img alt="" height="541" src="/images/copp boat.jpg" width="700"/></p>
<pre class="brush:py;auto-links:false;toolbar:false" contenteditable="false">threadFunction=function()
	-- Put your thread code here (initialization and clean-up code should not be in here)

	
	-- Some EXTERNAL commands (e.g. socket commands provided by Lua libraries)
	-- might appear as blocking to the simulator. In that case, you can define
	-- a non-blocking section as following example shows:
	--
	-- sim.setThreadIsFree(true) -- Start of the non-blocking section
	--
	-- Following 2 lines are meant as an example of EXTERNAL blocking commands:
	-- http = require("socket.http")
	-- print(http.request("http://www.google.com"))
	--
	-- sim.setThreadIsFree(false) -- End of the non-blocking section
	--
	-- While in a non-blocking section, try to avoid calling sim-functions. Also
	-- never forget to close the blocking section, otherwise V-REP will hang.
	-- Make sure you read the information related to the sim.setThreadIsFree
	-- API function in V-REP's documentation.


	-- If you wish to synchronize a threaded loop with each simulation pass,
	-- set the thread switch timing in the initialization phase of this script
	-- to the maximum (200), and manually switch thread here with the
	-- sim.switchThread() command. 
	-- ( sim.switchThread() will suspend this script's execution until next
	-- simulation pass, i.e. until the simulation time has changed )
	--
	-- Following example illustrates this:
	-- 
	-- while true do
	--     local p=sim.getObjectPosition(objHandle,-1)
	--     p[1]=p[1]+0.001
	--     sim.setObjectPosition(objHandle,-1,p)
	--     sim.switchThread()
	-- end
end

-- Put some initialization code here:
sim.setThreadSwitchTiming(2) -- Default timing for automatic thread switching

-- Here we execute the regular thread code:
res,err=xpcall(threadFunction,function(err) return debug.traceback(err) end)
if not res then
	sim.addStatusbarMessage('Lua runtime error: '..err)
end

-- Put some clean-up code here:
simRemoteApi.start(19999)
</pre>
<p></p>
<p><strong>Python Remote API :</strong></p>
<p><strong><img alt="" height="730" src="/images/boat python.jpg" width="569"/></strong></p>
<pre class="brush:py;auto-links:false;toolbar:false" contenteditable="false">import sim as vrep
import sys
# child threaded script: 
#simExtRemoteApiStart(19999)
 
vrep.simxFinish(-1)
 
clientID = vrep.simxStart('127.0.0.1', 19999, True, True, 5000, 5)
 
if clientID!= -1:
    print("Connected to remote server")
else:
    print('Connection not successful')
    sys.exit('Could not connect')
 
errorCode,boat_motor_handle=vrep.simxGetObjectHandle(clientID,'boat_motor',vrep.simx_opmode_oneshot_wait)
 
if errorCode == -1:
    print('Can not find motor')
    sys.exit()
 
errorCode=vrep.simxSetJointTargetVelocity(clientID,boat_motor_handle,-10, vrep.simx_opmode_oneshot_wait)</pre>
<p></p>
<h3>task 2-2</h3>
<p><strong>Stage2-ag1 Remote API 操控</strong></p>
<p><iframe allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen="allowfullscreen" frameborder="0" height="315" src="https://www.youtube.com/embed/fJ7Ux-6kHt0" title="YouTube video player" width="560"></iframe></p>
<p></p>
<p><strong>CoppeliaSim child script :</strong></p>
<p><img alt="" height="541" src="/images/copp boat.jpg" width="700"/></p>
<pre class="brush:py;auto-links:false;toolbar:false" contenteditable="false">threadFunction=function()
	-- Put your thread code here (initialization and clean-up code should not be in here)

	
	-- Some EXTERNAL commands (e.g. socket commands provided by Lua libraries)
	-- might appear as blocking to the simulator. In that case, you can define
	-- a non-blocking section as following example shows:
	--
	-- sim.setThreadIsFree(true) -- Start of the non-blocking section
	--
	-- Following 2 lines are meant as an example of EXTERNAL blocking commands:
	-- http = require("socket.http")
	-- print(http.request("http://www.google.com"))
	--
	-- sim.setThreadIsFree(false) -- End of the non-blocking section
	--
	-- While in a non-blocking section, try to avoid calling sim-functions. Also
	-- never forget to close the blocking section, otherwise V-REP will hang.
	-- Make sure you read the information related to the sim.setThreadIsFree
	-- API function in V-REP's documentation.


	-- If you wish to synchronize a threaded loop with each simulation pass,
	-- set the thread switch timing in the initialization phase of this script
	-- to the maximum (200), and manually switch thread here with the
	-- sim.switchThread() command. 
	-- ( sim.switchThread() will suspend this script's execution until next
	-- simulation pass, i.e. until the simulation time has changed )
	--
	-- Following example illustrates this:
	-- 
	-- while true do
	--     local p=sim.getObjectPosition(objHandle,-1)
	--     p[1]=p[1]+0.001
	--     sim.setObjectPosition(objHandle,-1,p)
	--     sim.switchThread()
	-- end
end

-- Put some initialization code here:
sim.setThreadSwitchTiming(2) -- Default timing for automatic thread switching

-- Here we execute the regular thread code:
res,err=xpcall(threadFunction,function(err) return debug.traceback(err) end)
if not res then
	sim.addStatusbarMessage('Lua runtime error: '..err)
end

-- Put some clean-up code here:
simRemoteApi.start(19999)
</pre>
<p></p>
<p><strong>Python Remote API :</strong></p>
<p><strong><img alt="" height="739" src="/images/car python.jpg" width="617"/></strong></p>
<pre class="brush:py;auto-links:false;toolbar:false" contenteditable="false">import sim as vrep
import sys
# child threaded script: 
#simExtRemoteApiStart(19999)
 
vrep.simxFinish(-1)
 
clientID = vrep.simxStart('127.0.0.1', 19999, True, True, 5000, 5)
 
if clientID!= -1:
    print("Connected to remote server")
else:
    print('Connection not successful')
    sys.exit('Could not connect')
 
errorCode,left_m_handle=vrep.simxGetObjectHandle(clientID,'left_m',vrep.simx_opmode_oneshot_wait)
 
errorCode,right_m_handle=vrep.simxGetObjectHandle(clientID,'right_m',vrep.simx_opmode_oneshot_wait)
 
if errorCode == -1:
    print('Can not find left or right motor')
    sys.exit()
 
errorCode=vrep.simxSetJointTargetVelocity(clientID,left_m_handle,-1, vrep.simx_opmode_oneshot_wait)
errorCode=vrep.simxSetJointTargetVelocity(clientID,right_m_handle,-1, vrep.simx_opmode_oneshot_wait)
</pre>
<p></p>
<h2>W12</h2>
<h3>上課直播</h3>
<p><strong>1.</strong>如何使用 remote api 來操控stage1和stage2的產品</p>
<p><strong>2.</strong>後面在查詢如何讓coppeliasim中感測器偵測到東西，使我們stage3中的機械手臂做動。</p>
<p></p>
<p><iframe allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen="allowfullscreen" frameborder="0" height="315" src="https://www.youtube.com/embed/Qh8_BvJDPto" title="YouTube video player" width="560"></iframe></p>
<h2>W13</h2>
<h3>小組meeting直播</h3>
<p><strong>1.</strong>討論stage3在coppeliasim中要如何匯入感測器，以及程式要如何編寫。</p>
<p><strong>2.</strong>討論W13中RobotDk機械手臂是如何做取放動做。</p>
<p><iframe allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen="allowfullscreen" frameborder="0" height="315" src="https://www.youtube.com/embed/a8Uw1WOhCYk" title="YouTube video player" width="560"></iframe></p>
<h3>RobotDK</h3>
<p><strong>1.</strong> 下載完RobotDK後開啟資料夾內的 <strong>a_start_robodk.bat </strong></p>
<p><strong>2.</strong>下載老師所提供的 <span> </span><a href="https://drive.google.com/file/d/1XoB3F5cPK8R4Y8AIWL5pKR5TQjPW8TRv/view?usp=sharing">Pick and Place</a></p>
<p><strong>3.</strong>在RobotDK內開啟檔案內的 <strong>Example 02-1 Pick and place with Python.rdk</strong></p>
<p><strong>4.</strong>將 <strong>pick_and_place.py </strong>放入 <strong>SciTE</strong> 並點選 <strong>Tools--&gt;GO</strong></p>
<p><strong>✴<span>若發生此情況，需要在編輯器上輸入</span><strong> pip install robodk</strong></strong></p>
<p><span><img alt="" height="473" src="/images/scite.jpg" width="555"/></span></p>
<p><img alt="" height="341" src="/images/cmd.jpg" width="654"/></p>
<p></p>
<p><strong>5.</strong>再<span>點選 </span><strong>Tools--&gt;GO </strong>會發現無法做動，那是因為程式裡的<strong> robotdk_ip='192.168.19.222'</strong> 為老師的ip位置，要使其運作，需改成自己電腦的ip位置 <strong>127.0.0.1</strong></p>
<p><img alt="" height="486" src="/images/scite pick.jpg" width="556"/></p>
<p></p>
<p>程式內容:</p>
<pre class="brush:py;auto-links:false;toolbar:false" contenteditable="false"># KMOLab Portable RoboDK pick and place
from robolink import *    # API to communicate with robodk
from robodk import *      # robodk robotics toolbox

# Setup global parameters
BALL_DIAMETER = 100 # diameter of one ball
APPROACH = 100      # approach distance to grab each part, in mm
nTCPs = 6           # number of TCP's in the tool

#----------------------------------------------
# Function definitions

def box_calc(BALLS_SIDE=4, BALLS_MAX=None):
    """Calculate a list of points (ball center) as if the balls were stored in a box"""
    if BALLS_MAX is None: BALLS_MAX = BALLS_SIDE**3
    xyz_list = []
    for h in range(BALLS_SIDE):
        for i in range(BALLS_SIDE):
            for j in range(BALLS_SIDE):
                xyz_list = xyz_list + [[(i+0.5)*BALL_DIAMETER, (j+0.5)*BALL_DIAMETER, (h+0.5)*BALL_DIAMETER]]
                if len(xyz_list) &gt;= BALLS_MAX:
                    return xyz_list
    return xyz_list

def pyramid_calc(BALLS_SIDE=4):
    """Calculate a list of points (ball center) as if the balls were place in a pyramid"""
    #the number of balls can be calculated as: int(BALLS_SIDE*(BALLS_SIDE+1)*(2*BALLS_SIDE+1)/6)
    BALL_DIAMETER = 100
    xyz_list = []
    sqrt2 = 2**(0.5)
    for h in range(BALLS_SIDE):
        for i in range(BALLS_SIDE-h):
            for j in range(BALLS_SIDE-h):
                height = h*BALL_DIAMETER/sqrt2 + BALL_DIAMETER/2
                xyz_list = xyz_list + [[i*BALL_DIAMETER + (h+1)*BALL_DIAMETER*0.5, j*BALL_DIAMETER + (h+1)*BALL_DIAMETER*0.5, height]]
    return xyz_list

def balls_setup(frame, positions):
    """Place a list of balls in a reference frame. The reference object (ball) must have been previously copied to the clipboard."""
    nballs = len(positions)
    step = 1.0/(nballs - 1)
    for i in range(nballs):
        newball = frame.Paste()
        newball.setName('ball ' + str(i)) #set item name
        newball.setPose(transl(positions[i])) #set item position with respect to parent
        newball.setVisible(True, False) #make item visible but hide the reference frame
        newball.Recolor([1-step*i, step*i, 0.2, 1]) #set RGBA color

def cleanup_balls(parentnodes):
    """Delete all child items whose name starts with \"ball\", from the provided list of parent items."""
    todelete = []
    for item in parentnodes:
        todelete = todelete + item.Childs()

    for item in todelete:
        if item.Name().startswith('ball'):
            item.Delete()

def TCP_On(toolitem, tcp_id):
    """Attach the closest object to the toolitem Htool pose,
    furthermore, it will output appropriate function calls on the generated robot program (call to TCP_On)"""
    toolitem.AttachClosest()
    toolitem.RDK().RunMessage('Set air valve %i on' % (tcp_id+1))
    toolitem.RDK().RunProgram('TCP_On(%i)' % (tcp_id+1));
        
def TCP_Off(toolitem, tcp_id, itemleave=0):
    """Detaches the closest object attached to the toolitem Htool pose,
    furthermore, it will output appropriate function calls on the generated robot program (call to TCP_Off)"""
    toolitem.DetachAll(itemleave)
    toolitem.RDK().RunMessage('Set air valve %i off' % (tcp_id+1))
    toolitem.RDK().RunProgram('TCP_Off(%i)' % (tcp_id+1));


#----------------------------------------------------------
# The program starts here:

# Any interaction with RoboDK must be done through RDK:
RDK = Robolink(robodk_path="C:/robodk/bin/RoboDK.exe", robodk_ip='127.0.0.1')

# Turn off automatic rendering (faster)
RDK.Render(False)

#RDK.Set_Simulation_Speed(500); # set the simulation speed

# Gather required items from the station tree
robot = RDK.Item('Fanuc M-710iC/50')
robot_tools = robot.Childs()
#robottool = RDK.Item('MainTool')
frame1 = RDK.Item('Table 1')
frame2 = RDK.Item('Table 2')

# Copy a ball as an object (same as CTRL+C)
ballref = RDK.Item('reference ball')
ballref.Copy()

# Run a pre-defined station program (in RoboDK) to replace the two tables
prog_reset = RDK.Item('Replace objects')
prog_reset.RunProgram()

# Call custom procedure to remove old objects
cleanup_balls([frame1, frame2])

# Make a list of positions to place the objects
frame1_list = pyramid_calc(4)
frame2_list = pyramid_calc(4)

# Programmatically place the objects with a custom-made procedure
balls_setup(frame1, frame1_list)

# Delete previously generated tools
for tool in robot_tools:
    if tool.Name().startswith('TCP'):
        tool.Delete()
        
# Calculate tool frames for the suction cup tool of 6 suction cups
TCP_list = []
for i in range(nTCPs):
    TCPi_pose = transl(0,0,100)*rotz((360/nTCPs)*i*pi/180)*transl(125,0,0)*roty(pi/2)
    TCPi = robot.AddTool(TCPi_pose, 'TCP %i' % (i+1))
    TCP_list.append(TCPi)

TCP_0 = TCP_list[0]

# Turn on automatic rendering
RDK.Render(True)

# Move balls    
robot.setPoseTool(TCP_list[0])
nballs_frame1 = len(frame1_list)
nballs_frame2 = len(frame2_list)
idTake = nballs_frame1 - 1
idLeave = 0
idTCP = 0
target_app_frame = transl(2*BALL_DIAMETER, 2*BALL_DIAMETER, 4*BALL_DIAMETER)*roty(pi)*transl(0,0,-APPROACH)

while idTake &gt;= 0:
    # ------------------------------------------------------------------
    # first priority: grab as many balls as possible
    # the tool is empty at this point, so take as many balls as possible (up to a maximum of 6 -&gt; nTCPs)
    ntake = min(nTCPs, idTake + 1)

    # approach to frame 1
    robot.setPoseFrame(frame1)
    robot.setPoseTool(TCP_0)
    robot.MoveJ([0,0,0,0,10,-200])
    robot.MoveJ(target_app_frame)

    # grab ntake balls from frame 1
    for i in range(ntake):
        TCPi = TCP_list[i]
        robot.setPoseTool(TCPi)
        # calculate target wrt frame1: rotation about Y is needed since Z and X axis are inverted
        target = transl(frame1_list[idTake])*roty(pi)*rotx(30*pi/180)
        target_app = target*transl(0,0,-APPROACH)
        idTake = idTake - 1        
        robot.MoveL(target_app)
        robot.MoveL(target)
        TCP_On(TCPi, i)
        robot.MoveL(target_app)
 
    # ------------------------------------------------------------------
    # second priority: unload the tool     
    # approach to frame 2 and place the tool balls into table 2
    robot.setPoseTool(TCP_0)
    robot.MoveJ(target_app_frame)
    robot.MoveJ([0,0,0,0,10,-200])
    robot.setPoseFrame(frame2)    
    robot.MoveJ(target_app_frame)
    for i in range(ntake):
        TCPi = TCP_list[i]
        robot.setPoseTool(TCPi)
        if idLeave &gt; nballs_frame2-1:
            raise Exception("No room left to place objects in Table 2")
        
        # calculate target wrt frame1: rotation of 180 about Y is needed since Z and X axis are inverted
        target = transl(frame2_list[idLeave])*roty(pi)*rotx(30*pi/180)
        target_app = target*transl(0,0,-APPROACH)
        idLeave = idLeave + 1        
        robot.MoveL(target_app)
        robot.MoveL(target)
        TCP_Off(TCPi, i, frame2)
        robot.MoveL(target_app)

    robot.MoveJ(target_app_frame)

# Move home when the robot finishes
robot.MoveJ([0,0,0,0,10,-200])
</pre>
<p></p><h2>W14</h2><h3>MTB_Robot</h3>
<p>組長<a href="https://40823131.github.io/cd2021/content/index.html">40823131</a>先做出<a href="https://40823131.github.io/cd2021/content/%E6%94%B9%E7%94%A8%20CoppeliaSim%20%E5%88%B6%E5%BC%8F%E7%9A%84%20Lua%20Script%20%E7%B7%A8%E5%AF%AB%E8%88%87%E5%8E%9F%E5%85%88%E5%8F%96%E6%94%BE%E6%96%B9%E5%A1%8A%E9%9B%B6%E4%BB%B6%E7%9B%B8%E5%90%8C%E7%9A%84%E6%93%8D%E6%8E%A7%E6%B5%81%E7%A8%8B.html">手臂程式</a>，我再和組長想出要如何在coppeliasim內新增UI介面，但介面操控上還有一些問題需要改進。</p>
<p><img alt="" height="334" src="/images/1623332585244.jpg" width="700"/></p>
<p><img alt="" height="239" src="/images/1623335008011.jpg" width="235"/></p>
<p><strong>手臂程式:(沒有UI介面)</strong></p>
<pre class="brush:lua;auto-links:false;toolbar:false" contenteditable="false">function sysCall_init()
    corout=coroutine.create(coroutineMain)
end
 
function sysCall_actuation()
    if coroutine.status(corout)~='dead' then
        local ok,errorMsg=coroutine.resume(corout)
        if errorMsg then
            error(debug.traceback(corout,errorMsg),2)
        end
    else
        corout=coroutine.create(coroutineMain)
    end
end
 
function movCallback(config,vel,accel,handles)
    for i=1,#handles,1 do
        if sim.getJointMode(handles[i])==sim.jointmode_force and sim.isDynamicallyEnabled(handles[i]) then
            sim.setJointTargetPosition(handles[i],config[i])
        else   
            sim.setJointPosition(handles[i],config[i])
        end
    end
end
 
function moveToConfig(handles,maxVel,maxAccel,maxJerk,targetConf,enable)
    local currentConf={}
    for i=1,#handles,1 do
        currentConf[i]=sim.getJointPosition(handles[i])
        targetConf[i]=targetConf[i]*math.pi/180
    end
    sim.moveToConfig(-1,currentConf,nil,nil,maxVel,maxAccel,maxJerk,targetConf,nil,movCallback,handles)
 
    if enable then
        sim.writeCustomDataBlock(gripperHandle,'activity','on')
    else
        sim.writeCustomDataBlock(gripperHandle,'activity','off')
    end
end
 
function coroutineMain()
    modelBase=sim.getObjectHandle(sim.handle_self)
    gripperHandle=sim.getObjectHandle('suctionPad')
    modelName=sim.getObjectName(modelBase)
    motorHandles = {}
    for i=1,4,1 do
        motorHandles[i]=sim.getObjectHandle('MTB_axis'..i)
    end
    local vel=60
    local accel=10
    local jerk=10
    local maxVel={vel*math.pi/180,vel*math.pi/180,vel*math.pi/180,vel*math.pi/180}
    local maxAccel={accel*math.pi/180,accel*math.pi/180,accel*math.pi/180,accel*math.pi/180}
    local maxJerk={jerk*math.pi/180,jerk*math.pi/180,jerk*math.pi/180,jerk*math.pi/180}
    moveToConfig(motorHandles,maxVel,maxAccel,maxJerk,{0,0,0,0},true)
    moveToConfig(motorHandles,maxVel,maxAccel,maxJerk,{0,0,1.9,0},true)
    moveToConfig(motorHandles,maxVel,maxAccel,maxJerk,{0,0,-1.9,0},true)
    moveToConfig(motorHandles,maxVel,maxAccel,maxJerk,{-160,-43.5,0,203.5},false)
    moveToConfig(motorHandles,maxVel,maxAccel,maxJerk,{160,43.5,0,203.5},false)
    moveToConfig(motorHandles,maxVel,maxAccel,maxJerk,{160,43.5,1.90,-203.5},true)
    moveToConfig(motorHandles,maxVel,maxAccel,maxJerk,{160,43.5,-1.90,-203.5},true)
end</pre>
<p><strong></strong></p>
<p><strong>手臂程式:(包含UI介面)</strong></p>
<pre class="brush:lua;auto-links:false;toolbar:false" contenteditable="false">function sysCall_init()
  --Notes can refer to the previous chapter
xml = [[
&lt;ui closeable="true" onclose="closeEventHandler" resizable="true" size="220,200"&gt;
    &lt;label text="MTB_Robot control" wordwrap="true" /&gt;
    
    &lt;group&gt;
        &lt;button text="Start move" onclick = "Start_move" /&gt;
        &lt;button text="Stop move" onclick = "Stop_move" /&gt;
        &lt;stretch /&gt;
    &lt;/group&gt;   
 
&lt;/ui&gt;
]] 
    ui=simUI.create(xml)

    
    --ui=simUI.create(xml)

    Start_flag = false
    Stop_flag = false
    modelBase=sim.getObjectHandle(sim.handle_self)
    gripperHandle=sim.getObjectHandle('suctionPad')
    modelName=sim.getObjectName(modelBase)
    motorHandles = {}
    local vel=10
    local accel=10
    local jerk=10
    local maxVel={vel*math.pi/180,vel*math.pi/180,vel*math.pi/180,vel*math.pi/180}
    local maxAccel={accel*math.pi/180,accel*math.pi/180,accel*math.pi/180,accel*math.pi/180}
    local maxJerk={jerk*math.pi/180,jerk*math.pi/180,jerk*math.pi/180,jerk*math.pi/180}
end
function closeEventHandler(h)
    sim.addStatusbarMessage('Window '..h..' is closing...')
    simUI.hide(h)
end
function Start_move(h)
    Start_flag = true
end
function Stop_move(h)
    Stop_flag = true   
end

function moveToConfig(handles,maxVel,maxAccel,maxJerk,targetConf,enable)
    local currentConf={}
    for i=1,#handles,1 do
        currentConf[i]=sim.getJointPosition(handles[i])
        targetConf[i]=targetConf[i]*math.pi/180
    end
    sim.moveToConfig(-1,currentConf,nil,nil,maxVel,maxAccel,maxJerk,targetConf,nil,movCallback,handles)

    if enable then
        sim.writeCustomDataBlock(gripperHandle,'activity','on')
    else
        sim.writeCustomDataBlock(gripperHandle,'activity','off')
    end
end
function sysCall_actuation()
        if Start_flag then
            for i=1,#handles,1 do
                if sim.getJointMode(handles[i])==sim.jointmode_force and sim.isDynamicallyEnabled(handles[i]) then
                    sim.setJointTargetPosition(handles[i],config[i])
                else    
                    sim.setJointPosition(handles[i],config[i])
                end
            end
        end
        if Stop_flag then

            sim.setJointTargetPosition('MTB_axis1',0)
            
        end
        
end

function movCallback(config,vel,accel,handles)
    
end
 

 
function sysCall_cleanup()
    -- do some clean-up here
    simUI.destroy(ui)
end</pre>
<p><strong>吸盤程式:</strong></p>
<pre class="brush:lua;auto-links:false;toolbar:false" contenteditable="false">function sysCall_init()
    modelBase=sim.getObjectHandle(sim.handle_self)
    s=sim.getObjectHandle('suctionPadSensor')
    l=sim.getObjectHandle('suctionPadLoopClosureDummy1')
    l2=sim.getObjectHandle('suctionPadLoopClosureDummy2')
    b=sim.getObjectHandle('suctionPadBodyRespondable')
    sim.setLinkDummy(l,-1)
    sim.setObjectParent(l,b,true)
    m=sim.getObjectMatrix(l2,-1)
    sim.setObjectMatrix(l,-1,m)
    suctionPadLink=sim.getObjectHandle('suctionPadLink')
    local gripperBase=sim.getObjectHandle(sim.handle_self)
    infiniteStrength=true
    maxPullForce=3
    maxShearForce=1
    maxPeelTorque=0.1
 
end
 
function sysCall_cleanup() 
    sim.setLinkDummy(l,-1)
    sim.setObjectParent(l,b,true)
    m=sim.getObjectMatrix(l2,-1)
    sim.setObjectMatrix(l,-1,m)
end
 
function sysCall_sensing() 
    parent=sim.getObjectParent(l)
    local on=sim.readCustomDataBlock(modelBase,'activity')=='on'
    if not on then
        if (parent~=b) then
            sim.setLinkDummy(l,-1)
            sim.setObjectParent(l,b,true)
            m=sim.getObjectMatrix(l2,-1)
            sim.setObjectMatrix(l,-1,m)
        end
    else
        if (parent==b) then
            index=0
            while true do
                shape=sim.getObjects(index,sim.object_shape_type)
                if (shape==-1) then
                    break
                end
                local res,val=sim.getObjectInt32Parameter(shape,sim.shapeintparam_respondable)
                if (shape~=b) and (val~=0) and (sim.checkProximitySensor(s,shape)==1) then
                    -- Ok, we found a respondable shape that was detected
                    -- We connect to that shape:
                    -- Make sure the two dummies are initially coincident:
                    sim.setObjectParent(l,b,true)
                    m=sim.getObjectMatrix(l2,-1)
                    sim.setObjectMatrix(l,-1,m)
                    -- Do the connection:
                    sim.setObjectParent(l,shape,true)
                    sim.setLinkDummy(l,l2)
                    break
                end
                index=index+1
            end
        else
            -- Here we have an object attached
            if (infiniteStrength==false) then
                -- We might have to conditionally beak it apart!
                result,force,torque=sim.readForceSensor(suctionPadLink) -- Here we read the median value out of 5 values (check the force sensor prop. dialog)
                if (result&gt;0) then
                    breakIt=false
                    if (force[3]&gt;maxPullForce) then breakIt=true end
                    sf=math.sqrt(force[1]*force[1]+force[2]*force[2])
                    if (sf&gt;maxShearForce) then breakIt=true end
                    if (torque[1]&gt;maxPeelTorque) then breakIt=true end
                    if (torque[2]&gt;maxPeelTorque) then breakIt=true end
                    if (breakIt) then
                        -- We break the link:
                        sim.setLinkDummy(l,-1)
                        sim.setObjectParent(l,b,true)
                        m=sim.getObjectMatrix(l2,-1)
                        sim.setObjectMatrix(l,-1,m)
                    end
                end
            end
        end
    end
end</pre>
<p><strong></strong></p>
<p><strong></strong></p><h2>W15</h2>
<h3>Geometry Translation</h3>
<p>Inverse kinematics for a 2-joint robot arm using geometry <strong>翻譯</strong></p>
<p><span></span></p>
<p><span><strong>0:05</strong><br/> We saw this simple two-link robot in the previous lecture about forward kinematics.</span></p>
<p>我們在上一堂關於正向運動學的課程中看到這個簡單的雙連桿機構。</p>
<p><span>Kinematics : </span>運動學</p>
<p><strong>0:10</strong></p>
<p><span>The tooltip pose of this robot is described simply by two numbers, the coordinates x and y with respect to the world coordinate frame.</span></p>
<p>該機構的提示框由兩個數字簡單描述，相對於世界坐標系的坐標<span> x </span>和<span> y</span>。</p>
<p><span>Tooltip : </span>提示框</p>
<p><strong>0:19</strong></p>
<p><span>So, the problem here is that given x and y, we want to determine the joined angles, q1 and q2.</span></p>
<p>所以，這裡的問題是給定<span>x</span>和<span>y</span>，我們要判斷連接角<span>q1</span>和<span>q2</span>。</p>
<p><strong>0:25</strong></p>
<p><span>The solution that we’re going to follow in this particular section is a geometric one.</span></p>
<p>我們利用特定幾何來解決此方案。</p>
<p><strong>0:29</strong></p>
<p><span>We’re going to start with a simple piece of construction.</span></p>
<p>我們從一個簡單的結構開始。</p>
<p><strong>0:31</strong></p>
<p><span>We’re going to overlay the red triangle on top of our robot.</span></p>
<p>我們在機構上覆蓋紅色三角形。</p>
<p><strong>0:35</strong></p>
<p><span>We know that the end point coordinate is x, y, so the vertical height of the triangle is y, the horizontal width is x.</span></p>
<p>我們知道終點坐標是<span>x</span>，<span>y</span>，所以三角形的垂直高度是<span>y</span>，水平寬度是<span>x</span>。</p>
<p><strong>0:43</strong></p>
<p><span>And, using Pythagoras theorem, we can write r squared equals x squared plus y squared.</span></p>
<p>利用畢氏定理<span>(Pythagorean theorem)</span>，我們可寫出 r² = x ²+ y²</p>
<p><strong>0:50</strong></p>
<p><span>So far, so easy.</span></p>
<p>到目前為止很容易。</p>
<p><strong>0:51</strong></p>
<p><span>Now, w’re going to look at this triangle highlighted here in red and we want to determine the angle alpha.</span></p>
<p>現在，我們查看此凸顯的紅色三角形，並確定α角。</p>
<p><strong>0:58</strong></p>
<p><span>In order to do that, we need to use the cosine rule.</span></p>
<p>為了做到這一點，我們須使用餘弦定理<span> (Law of cosines)</span>。</p>
<p><strong>1:01</strong></p>
<p><span>And, if you’re a little rusty on the cosine rule, here is a bit of a refresher.</span></p>
<p>如果你對餘弦定理有點生疏，這裡幫以複習一點點。</p>
<p><strong>1:06</strong></p>
<p><span>We have an arbitrary triangle.</span></p>
<p>有一個任意三角形。</p>
<p><strong>1:08</strong></p>
<p><span>We don’t have any right angles in it and we’re going to label the length of this edge as A and the angle opposite that edge, we’re going to label as little a.</span></p>
<p>我們沒有任何的直角，將這邊的角度標為小<span>a</span>，而對邊的長度標為<span>A</span>。</p>
<p><strong>1:16</strong></p>
<p><span>And, we do the same for this edge and this angle, and this edge and this angle.</span></p>
<p>我們再對這邊和這個角，以及這邊和這個叫做同樣的事。</p>
<p><strong>1:21</strong></p>
<p><span>So, all together, the sides are labelled capitals A, B and C, and the angles are labelled little a, little b, and little c.</span></p>
<p>因此所有邊都標記為<span>A, B, C</span>，角都標記為<span>a, b, c </span>。</p>
<p><strong>1:30</strong></p>
<p><span>So, the cosine rule is simply this relationship here.</span></p>
<p>餘弦定理就是這種關係。</p>
<p><strong>1:33</strong></p>
<p><span>It’s a bit like Pythagoras’ theorem except for this extra term on the end with the cos a in it.</span></p>
<p>它有點像畢達哥拉斯定理，除了末尾有<span>cos a</span>。</p>
<p><strong>1:39</strong></p>
<p><span>Now, let’s apply the cosine rule to the particular triangle we looked at a moment ago.</span></p>
<p>將餘弦定理應用在剛看到的特定三角形。</p>
<p><strong>1:45</strong></p>
<p><span>It’s pretty straightforward to write down this particular relationship.</span></p>
<p>寫下此特殊關係很簡單。</p>
<p><strong>1:48</strong></p>
<p><span>We can isolate the term cos alpha which gives us the angle alpha that we’re interested in.</span></p>
<p>我們可分離出<span> cos</span>α ，它給我們需要的α角度。</p>
<p><strong>1:53</strong></p>
<p><span>And, it’s defined in terms of the constant link lengths, A1 and A2 and the position of the end effector, x and y.</span></p>
<p>它是根據恆定連趕長度<span>A1</span>和<span>A2</span>以及末端執行器的位置<span>x</span>和<span>y</span>定義。</p>
<p><strong>2:02</strong></p>
<p><span>We can write this simple relationship between the angles alpha and q2.</span></p>
<p>我們可寫出角度α和<span>q2</span>之間的簡單關係。</p>
<p><strong>2:07</strong></p>
<p><span>And, we know from the shape of the cosine function that cos of q2 must be equal to negative of cos alpha.</span></p>
<p>並且我們從餘弦函數中得知<span>cos q2</span>必須等於 <span>–cos </span>α。</p>
<p><strong>2:13</strong></p>
<p><span>This time, let’s just write an expression for the cosine of the joined angle q2.</span></p>
<p>寫餘弦在連接角q2的表達式。</p>
<p><strong>2:18</strong></p>
<p><span>Now, we’re going to draw yet another red triangle and we’re going apply some simple trigonometry here.</span></p>
<p>我們繪製另一個紅色三角形，並應用三角函數。</p>
<p><strong>2:24</strong></p>
<p><span>If we know q2, then we know this length and this length of the red triangle.</span></p>
<p>如果我們知道<span>q2</span>，就可知道這個長度和這個三角形的長度。</p>
<p><strong>2:29</strong></p>
<p><span>We can write this relationship for the sine of the joined angle q2.</span></p>
<p>我們可以在連接角<span>q2</span>寫出正弦關係。</p>
<p><strong>2:33</strong></p>
<p><span>Now, we can consider this bigger triangle whose angle is beta and this side length of this triangle is given here in blue.</span></p>
<p>現在我們考慮這個大三角形，角度是β，此三角形的邊長由藍色表示。</p>
<p><strong>2:42</strong></p>
<p><span>And, the length of the other side of the triangle is this.</span></p>
<p>且三角形另一邊長度是這個。</p>
<p><strong>2:45</strong></p>
<p><span>So, now we can write an expression for the angle beta in terms of these parameters here.</span></p>
<p>我們可在此根據參數寫出角度β的表達式。</p>
<p><strong>2:52</strong></p>
<p><span>Going back to the red triangle that we drew earlier, we can establish a relationship between q1 and the angle beta.</span></p>
<p>回到之前畫的三角形，我們可建立出<span>q1</span>和β的關係。</p>
<p><strong>2:59</strong></p>
<p><span>Introduce yet another angle, this one gamma and we can write a relationship between the angle gamma and the tooltip coordinates x and y.</span></p>
<p>引入另一個角度<span>ɣ</span>，可寫出角度<span>ɣ</span>和提示座標<span>x</span>和<span>y</span>之間的關係。</p>
<p><strong>3:09</strong></p>
<p><span>Now, we can write a simple relationship between the angles that we’ve constructed, gamma and beta and the joined angle we’re interested in which is q1.</span></p>
<p>現在我們可建構出角度β和<span>ɣ</span>與連接角度<span>q1</span>之間的關係。</p>
<p><strong>3:17</strong></p>
<p><span>And, the total relationship looks something like this.</span></p>
<p>而且，整個關係看起來像這樣。</p>
<p><strong>3:20</strong></p>
<p><span>Quite a complex relationship, it gives us the angle of joined one, that’s q1 in terms of the end effector coordinates y and x, and a bunch of constants, a1 and a2, and it’s also a function of the second joint angle, q2.</span></p>
<p>相當複雜的關係，它提供連接的角度，即末端執行器坐標<span> y </span>和<span> x </span>的<span> q1</span>，以及一系列常數<span> a1 </span>和<span> a2</span>，它也是第二個關節角度<span> q2 </span>的函數。</p>
<p><strong>3:36</strong></p>
<p><span>So, let’s summarize what it is that we have derived here.</span></p>
<p>所以，總結我們在這裡得出了什麼。</p>
<p><strong>3:40</strong></p>
<p><span>We have an expression for the cosine of q2 and we have an expression for q1.</span></p>
<p>我們有<span>q1</span>和<span>cosq2</span>方程式。</p>
<p><strong>3:45</strong></p>
<p><span>Now, the cosine function is symmetrical about 0.</span></p>
<p>餘弦函數在<span>0</span>對稱。</p>
<p><strong>3:49</strong></p>
<p><span>So, if we know the value of the cosine of q2, then there are two possible solutions a positive angle and a negative angle.</span></p>
<p>所以我們知道<span>cosq2</span>的值可能為正角和負角。</p>
<p><strong>3:57</strong></p>
<p><span>We’re going to explicitly choose the positive angle. Which means that I can write this expression here.</span></p>
<p>我們選擇正角，表示我可以寫出此表達式。</p>
<p><strong>4:03</strong></p>
<p><span>And now, we have what we call the inverse kinematic solution for this two-link robot.</span></p>
<p>現在我們能用逆向運動學來解決雙連桿機構。</p>
<p><strong>4:08</strong></p>
<p><span>We have an expression for the two joined angles, q1 and q2 in terms of the end effector pose x and y, and a bunch of constants.</span></p>
<p>我們有兩個連接角<span> q1 </span>和<span> q2 </span>的表達式，根據末端執行器<span>x </span>和<span> y </span>以及一系列常量。</p>
<p><strong>4:17</strong></p>
<p><span>You notice that the two equations are not independent.</span></p>
<p>注意到兩方程式不是獨立的。</p>
<p><strong>4:19</strong></p>
<p><span>The equation for q1, in fact, depends on the solution for q2.</span></p>
<p>事實上，<span>q1</span>方程式取決於<span>q2</span>的解。</p>
<p><strong>4:23</strong></p>
<p><span>In this case, q2 is negative and we’re going to write the solution for q2 with a negative sign in front of the inverse cosine.</span></p>
<p>在這情況下，<span>q2</span>為負，我們將在<span>q2</span>反餘弦的解錢加上負號。</p>
<p><strong>4:32</strong></p>
<p><span>Now, we need to solve for q1, so we’re going to introduce this particular red triangle, the angle beta that we solved previously, and the angle gamma which is defined in terms of y and x.</span></p>
<p>我們需求解<span>q1</span>，因此采用這個特定的三角形，之前求解的角度β以及根據<span>y</span>和<span>x</span>定義的角度<span>ɣ</span>。</p>
<p><strong>4:44</strong></p>
<p><span>Now, we write a slightly different relationship between q1, gamma and beta, different to what we had before.</span></p>
<p><span>q1</span>、<span>ɣ</span>和β之間的關西，和之前求的不同。</p>
<p><strong>4:50</strong></p>
<p><span>There’s a change of sign involved.</span></p>
<p>涉及到符號的變化。</p>
<p><strong>4:51</strong></p>
<p><span>Then, we can substitute all that previous equation and come up with this expression for q1.</span></p>
<p>然後我們可代換之前所有等式，並求得此<span>q1</span>表達式。</p>
<p><strong>4:56</strong></p>
<p><span>Again, there is a change of sign here.</span></p>
<p>同樣，這裡的符號發生了變化。</p>
<p><strong>4:58</strong></p>
<p><span>Previously, this was a negative sign.</span></p>
<p>先前，這是個負號。</p>
<p><strong>5:01</strong></p>
<p><span>And, here in summary form is the solution for the inverse kinematics of our two-link robot when it is in this particular configuration, where q2 is negative.</span></p>
<p>這是雙連桿機構在此逆向運動學的總形式，其中<span>q2</span>為負。</p>
<p><strong>5:10</strong></p>
<p><span>Let’s compare the two solutions, the case where q2 is positive and the case where q2 is negative.</span></p>
<p>讓我們比較兩個解決方案，<span>q2</span>為正和<span>q2</span>為負的情況。</p>
<h3>Algebra Translation</h3>
<p>Inverse kinematics for a 2-joint robot arm using algebra <strong>翻譯</strong></p>
<p><strong>0:04</strong></p>
<p>Here we have the same two link robot as we just looked at but this time we're going tosolve it using an analytical approach , that is we're going to rely much more on algebra ,particular linear algebra rather than geometry .</p>
<p>在這裡，我們有與前一篇相同的兩連桿機械手臂，但這次我們將使用分析方法來解決它，意味著我們將更多地依賴代數，特別是使用線性代數而不是幾何。</p>
<p><strong>0:16</strong></p>
<p>We have an expression E , which is the homogeneous transformation which represents the pose of the robots endefector and we looked at this in the last lecture , we can write the endefector pose as a sequence of elementary homogeneous transformations .</p>
<p>我們有一個表達式 E，它是表示機械手臂最終位置的齊次變換式，我們在上一課中看到了這一點，我們可以將最終位置寫為一系列基本齊次變換式。</p>
<p><strong>0:33</strong></p>
<p>A rotation by Q1 , a translation along the X direction by A1 , a rotation by Q2 and then a translation in the X direction by A2 .</p>
<p>Q1 旋轉，A1 沿 X 方向平移，Q2 旋轉，然後 A2 沿 X 方向平移。</p>
<p><strong>0:43</strong></p>
<p>If I expand this out , multiply all the transformations together , I get the expression shown here ; a three by three homogeneous transformation matrix representing the pose of the robot's endefector.</p>
<p>如果我將其展開，將所有變換相乘，就會得到此處所示的表達式 E ;它是一個三乘三的齊次變換矩陣，表示機械手臂的最終的位置。</p>
<p><strong>0:56</strong></p>
<p>Now for this particular two link robot , we are only interested in the position of its endefector , it's X and Y co - ordinate and they are these two elements within the homogeneous transformation matrix , so I'm going to copy those out .</p>
<p>現在對於這個特殊的兩連桿機器人，我們只對它的最終位置感興趣，與它有關的是 X 和 Y 坐標，它們是齊次變換矩陣中的這兩個元素，所以我將把它們複製出來。</p>
<p><strong>1:10</strong></p>
<p>So here again is our expression for X and Y and what we're going to do is a fairly common trick , we're going to square and add these two equations and I get a relationship that looks like this .</p>
<p>所以這裡又是我們對 X 和 Y 的表達式，我們要做的是一個相當常見的技巧，我們要將它平方並將這兩個方程相加，我得到一個看起來像這樣的關係式。</p>
<p><strong>1:22</strong></p>
<p>Now I can solve for the joint angle Q2 in terms of the endefector pose X and Y and the robot's constants A1 and A2.</p>
<p>現在我可以根據最終位置X和Y以及機械手臂的常數A1及A2來求出關節角度Q2。</p>
<p><strong>1:32</strong></p>
<p>Now what I'm going to do is apply the sum of angles identity .</p>
<p>現在我要做的是應用角度之和的特性。</p>
<p><strong>1:35</strong></p>
<p>I'm going to expand these terms, sine of Q1 plus Q2 or cos of Q1 plus Q2 and to make life a little bit easier, I'm going to make some substations, so where ever I had cos Q2, I'm going to write C2 and where ever I had sine Q2, I'm going to write S2.</p>
<p>我將展開這些項，Q1 的正弦加 Q2 或 Q1 的餘弦加 Q2，為了讓生活更輕鬆一點，我將建立一些分部，所以只要有 cos Q2，我會將其取代為C2並且在有正弦Q2的地方，我會將其取代為S2。</p>
<p><strong>1:51</strong></p>
<p>It's a fairly common shorthand when people are looking at robot kinematic equations.</p>
<p>當人們解決機械手臂運動學方程式時，這是一個相當常見的快速記法。</p>
<p><strong>1:57</strong></p>
<p>And here are the equations after making those substitutions.</p>
<p>這是進行替換後的方程式。</p>
<p><strong>2:00</strong></p>
<p>Looking at these two equations, I can see that they fall into a very well known form and for that form there is a very well known solution.</p>
<p>看看這兩個方程式，我可以看到它們屬於一個眾所周知的形式，對於這種形式，有一個淺顯易見的解決方案。</p>
<p><strong>2:09</strong></p>
<p>So I'm going to consider just one of the equations, the equation for Y and using our well known identity and it's solution, I can determine the values for the variables little a, little b and little c and once l've determined those, then I can just write down the solution for Q1, which x is the equivalent of theta in this particular case.</p>
<p>所以我將只考慮其中一個方程，Y 的方程，並使用我們眾所周知的恆等式和它的解，我可以確定變量小 a、小 b 和小 c 的值，一旦我確定了這些，然後我可以寫下 Q1 的解決方程，在這種特殊情況下，x 相當於 <span>θ</span>。</p>
<p><strong>2:31</strong></p>
<p>Here again is our expression for Q1, copied over from the previous slide and we may remember from earlier in our workings that we determined this particular relationship; X squared plus Y squared is equal to this particular complex expression.</p>
<p>這裡再次是我們對 Q1 的表達，從上一張幻燈片複製過來，我們可能還記得在我們早期的說明中，確定了這種特殊關係； X 平方加 Y 平方等於這個特定的複雜表達式。</p>
<p><strong>2:45</strong></p>
<p>So I can substitute that in and do some simplification and I end up with this slightly less complex expression for Q1.</p>
<p>因此，我可以將其替換並進行一些簡化，最終得到 Q1 的這個稍微不那麼複雜的表達式。</p>
<p><strong>2:53</strong></p>
<p>And it is the same expression that I got following the geometric approach in the previous section.</p>
<p>這與我在上一節中遵循幾何方法求出的表達式一模一樣。</p>
<p><span> </span></p>
<h2>W16</h2>
<h3>Onshape 零組件繪製</h3>
<p><strong>Oneshape零件圖檔連結:</strong></p>
<p><a href="https://cad.onshape.com/documents/1bd7d40e39fd6f5571b76d90/w/42d05e8a70a7d2de58f16d17/e/ea18445bee2b29bfe8c98c6a">MTB_Base</a></p>
<p></p>
<p><a href="https://cad.onshape.com/documents/85ccdae53fcb2ae16419633a/w/0ecfb961f83e0a823d0e4cac/e/ce63400ca4f438fbc380e009">MTB_Link1</a></p>
<p></p>
<p><a href="https://cad.onshape.com/documents/6a46b8691060a1eff6a4aa56/w/d30244d6c2c2887a0ec2c53e/e/f1e46bd76cfd744f37fe29b7">MTB_Link2</a></p>
<p></p>
<p><a href="https://cad.onshape.com/documents/a5436399f8b533fabf82e2ec/w/4c25105fbfed2fda98d67369/e/6e2927d91ec0dc360b629ef4">MTB_Link3</a></p>
<p></p>
<p><strong>製作流程:</strong></p>
<p><strong></strong></p>
<p><iframe allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen="allowfullscreen" frameborder="0" height="315" src="https://www.youtube.com/embed/nrvD2arC9a4" title="YouTube video player" width="560"></iframe></p><h1>Product Drawing</h1>
<h2>stage1-ag10</h2>
<p>Inventor:<a href="https://drive.google.com/drive/folders/1OMjDAU-FfpDeHJmzYHOAeyjqFkp-jZ64?usp=sharing">達爾文船零件圖檔</a></p>
<p><img alt="" height="547" src="/images/下載.png" width="600"/></p>
<p>Coppeliasim:<a href="https://drive.google.com/file/d/1oUa0TqjUl8eEl164-AIq4JRf0pyS5H_n/view?usp=sharing">達爾文船模擬圖檔</a></p>
<p><img alt="" height="368" src="/images/final.jpg" width="600"/></p>
<h2>stage2-ag1</h2>